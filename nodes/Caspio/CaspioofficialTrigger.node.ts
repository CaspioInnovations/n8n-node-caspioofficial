import type {
	IHookFunctions,
	IWebhookFunctions,
	INodeType,
	INodeTypeDescription,
	IWebhookResponseData,
	IDataObject,
} from 'n8n-workflow';
import { createHmac, randomBytes } from 'crypto';
import { NodeApiError, NodeOperationError } from 'n8n-workflow';
import { caspioApiRequest } from './helpers/api';
import { listSearch, loadOptions, resourceMapping } from './methods';
import { tableRLC } from './helpers/ui/resource.properties';
import { filterOutPasswordFields } from './helpers/utils';
import type { CaspioField, CaspioWebhooksResponse, CaspioWebhook } from './helpers/interfaces';

function extractWebhookId(webhookUrl: string): string {
	const url = new URL(webhookUrl);
	const pathSegments = url.pathname.split('/');
	const webhookIndex = pathSegments.findIndex(
		(segment) => segment === 'webhook' || segment === 'webhook-test',
	);
	if (webhookIndex !== -1 && pathSegments[webhookIndex + 1]) {
		return pathSegments[webhookIndex + 1];
	}
	return Date.now().toString();
}

function buildWebhookDescription(
	notes: string | undefined,
	workflowId: string | undefined,
	workflowName: string | undefined,
	instanceBaseUrl: string,
): string {
	const parts: string[] = [];

	parts.push('Auto-generated by n8n. Do not modify to ensure correct workflow operation.');

	if (workflowId) {
		parts.push(`Workflow: ${workflowName || 'Unnamed'}.`);
		const baseUrl = instanceBaseUrl.endsWith('/') ? instanceBaseUrl.slice(0, -1) : instanceBaseUrl;
		const workflowUrl = `${baseUrl}/workflow/${workflowId}`;
		parts.push(`URL: ${workflowUrl}`);
	}

	if (notes && notes.trim()) {
		parts.push(`Notes: ${notes.trim()}`);
	}

	return parts.join('\n');
}

function buildCustomPayloadTemplate(
	fields: string[],
	attachmentFields: string[],
	returnAttachmentUrls: boolean,
): string {
	const webhookMetadata: string[] = [];
	const dataFields: string[] = [];

	webhookMetadata.push(`'secret': '[@out-hook:secret]'`);
	webhookMetadata.push(`'webhookId': '[@out-hook:webhookId]'`);
	webhookMetadata.push(`'messageId': '[@out-hook:messageId]'`);
	webhookMetadata.push(`'eventId': '[@out-hook:eventId]'`);
	webhookMetadata.push(`'callId': '[@out-hook:callId]'`);
	webhookMetadata.push(`'accountId': '[@out-hook:accountId]'`);
	webhookMetadata.push(`'eventDate': '[@out-hook:eventDate]'`);
	webhookMetadata.push(`'eventType': '[@out-hook:eventType]'`);
	webhookMetadata.push(`'objectName': '[@out-hook:objectName]'`);

	dataFields.push(`'PK_ID': '[@field:PK_ID]'`);

	for (const fieldName of fields) {
		if (attachmentFields.includes(fieldName)) {
			dataFields.push(`'${fieldName}': '[@field:${fieldName}]'`);
			if (returnAttachmentUrls) {
				dataFields.push(`'_${fieldName}': '[@field:${fieldName}/]'`);
			}
		} else {
			dataFields.push(`'${fieldName}': '[@field:${fieldName}]'`);
		}
	}

	const dataObject = `{${dataFields.join(', ')}}`;
	const template = `{${webhookMetadata.join(', ')}, 'data': [${dataObject}]}`;

	return template;
}

function generateSalt(): string {
	return randomBytes(16).toString('hex');
}

function hashSecret(secret: string, salt: string): string {
	return createHmac('sha256', salt).update(secret).digest('hex');
}

function storeHashedSecret(webhookData: IDataObject, secret: string): void {
	const salt = generateSalt();
	webhookData.salt = salt;
	webhookData.secretHash = hashSecret(secret, salt);
}

export class CaspioofficialTrigger implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Caspio Trigger',
		name: 'CaspioofficialTrigger',
		icon: 'file:caspio.svg',
		group: ['trigger'],
		version: 1,
		description: 'Starts the workflow when Caspio table events occur.',
		documentationUrl:
			'https://howto.caspio.com/integrate-your-apps/integration-with-n8n/n8n-integration-triggers',
		defaults: {
			name: 'Caspio Trigger',
		},
		inputs: [],
		outputs: ['main'],
		credentials: [
			{
				name: 'caspioOAuth2Api',
				required: true,
			},
		],
		webhooks: [
			{
				name: 'default',
				httpMethod: 'POST',
				responseMode: 'onReceived',
				path: 'webhook',
			},
		],
		properties: [
			{
				displayName: 'Notes',
				name: 'notes',
				type: 'string',
				default: '',
				description: 'Notes that will be included in the webhook description (optional)',
			},
			{
				displayName: 'Event',
				name: 'event',
				type: 'options',
				noDataExpression: true,
				options: [
					{
						name: 'Record Created',
						value: 'insert',
						description: 'To get notified of any record is created in a table',
						action: 'On record created',
					},
					{
						name: 'Record Updated',
						value: 'update',
						description: 'To get notified of any record is updated in a table',
						action: 'On record updated',
					},
					{
						name: 'Record Deleted',
						value: 'delete',
						description: 'To get notified of any record is deleted in a table',
						action: 'On record deleted',
					},
				],
				default: 'insert',
				description: 'Which table event should trigger this webhook',
			},
			{
				...tableRLC,
				displayOptions: {
					show: {
						event: ['insert', 'update', 'delete'],
					},
				},
			},
			{
				displayName: 'When Any Field Is Changed',
				name: 'whenAnyFieldChanged',
				type: 'boolean',
				noDataExpression: true,
				default: true,
				displayOptions: {
					show: {
						event: ['update'],
					},
				},
				description: 'Whether the webhook triggers on changes to any field',
			},
			{
				displayName: 'Field Names or IDs',
				name: 'whenFieldsChanged',
				type: 'multiOptions',
				typeOptions: {
					loadOptionsMethod: 'getTableUpdateableFields',
					loadOptionsDependsOn: ['table.value'],
				},
				default: [],
				displayOptions: {
					show: {
						event: ['update'],
						whenAnyFieldChanged: [false],
					},
				},
				description:
					'Choose from the list, or specify IDs using an <a href="https://docs.n8n.io/code/expressions/">expression</a>',
			},
			{
				displayName: 'Send All Fields',
				name: 'sendAllFields',
				type: 'boolean',
				noDataExpression: true,
				default: true,
				displayOptions: {
					show: {
						event: ['insert', 'update', 'delete'],
					},
				},
				description:
					'Whether to include all table fields in the webhook payload. Password fields are automatically excluded for security reasons.',
			},
			{
				displayName: 'Selected Field Names or IDs',
				name: 'selectedFields',
				type: 'multiOptions',
				typeOptions: {
					loadOptionsMethod: 'getColumns',
					loadOptionsDependsOn: ['table.value'],
				},
				default: [],
				displayOptions: {
					show: {
						event: ['insert', 'update', 'delete'],
						sendAllFields: [false],
					},
				},
				description:
					'Choose which fields to include in the webhook payload. Choose from the list, or specify IDs using an <a href="https://docs.n8n.io/code/expressions/">expression</a>.',
			},
			{
				displayName: 'Advanced Options',
				name: 'advancedOptions',
				type: 'collection',
				placeholder: 'Add Option',
				default: {},
				options: [
					{
						displayName: 'Event Sources',
						name: 'eventSources',
						type: 'multiOptions',
						noDataExpression: true,
						options: [
							{ name: 'DataPages', value: 'DataPages' },
							{ name: 'DataParts', value: 'DataParts' },
							{ name: 'Datasheet', value: 'Datasheet' },
							{ name: 'Extensions', value: 'Extensions' },
							{ name: 'Tasks', value: 'Tasks' },
							{ name: 'Triggered Actions', value: 'TriggeredActions' },
						],
						default: [
							'DataPages',
							'DataParts',
							'Datasheet',
							'Extensions',
							'Tasks',
							'TriggeredActions',
						],
						description:
							'Sources that can trigger the webhook event. By default, all available sources are selected.',
					},
					{
						displayName: 'Return Attachment URLs',
						name: 'returnAttachmentUrls',
						type: 'boolean',
						noDataExpression: true,
						default: false,
						description:
							'Whether to add temporary download URLs for attachment fields (as _FieldName) alongside the filenames. URLs are valid for 300 seconds.',
					},
				],
			},
		],
		usableAsTool: true,
	};

	methods = {
		listSearch,
		loadOptions,
		resourceMapping,
	};

	webhookMethods = {
		default: {
			async checkExists(this: IHookFunctions): Promise<boolean> {
				const webhookUrl = this.getNodeWebhookUrl('default') as string;
				const webhookData = this.getWorkflowStaticData('node');
				const isTestWebhook = webhookUrl.includes('/webhook-test/');
				webhookData.isTestWebhook = isTestWebhook;
				if (isTestWebhook) {
					return false;
				}

				const webhookId = extractWebhookId(webhookUrl);
				const expectedName = `n8n-${webhookId}`;

				const webhooks = (await caspioApiRequest.call(this, {
					method: 'GET',
					path: '/v3/outgoingWebhooks',
				})) as CaspioWebhooksResponse;
				for (const w of webhooks.Result || []) {
					if (w.Name === expectedName && w.OutgoingUrls?.includes(webhookUrl)) {
						webhookData.webhookId = w.Id;
						storeHashedSecret(webhookData, w.Secret as string);
						return true;
					}
				}
				return false;
			},

			async create(this: IHookFunctions): Promise<boolean> {
				const webhookData = this.getWorkflowStaticData('node');
				const webhookUrl = this.getNodeWebhookUrl('default') as string;
				const notes = this.getNodeParameter('notes', '') as string;

				const webhookId = extractWebhookId(webhookUrl);
				const expectedName = `n8n-${webhookId}`;

				const workflow = this.getWorkflow();
				const instanceBaseUrl = this.getInstanceBaseUrl();
				const desc = buildWebhookDescription(notes, workflow.id, workflow.name, instanceBaseUrl);
				const operation = this.getNodeParameter('event') as 'insert' | 'update' | 'delete';
				const tableName = this.getNodeParameter('table', undefined, {
					extractValue: true,
				}) as string;
				const advancedOptions = this.getNodeParameter('advancedOptions') as IDataObject;

				const sendAllFields = this.getNodeParameter('sendAllFields', true) as boolean;
				const selectedFields = this.getNodeParameter('selectedFields', []) as string[];
				const whenAnyFieldChanged = this.getNodeParameter('whenAnyFieldChanged', true) as boolean;
				const whenFieldsChanged = this.getNodeParameter('whenFieldsChanged', []) as string[];
				const returnAttachmentUrls = (advancedOptions.returnAttachmentUrls as boolean) || false;

				const isTestWebhook = webhookUrl.includes('/webhook-test/');
				webhookData.isTestWebhook = isTestWebhook;
				const effectiveName = isTestWebhook ? `${expectedName}_test_${Date.now()}` : expectedName;

				let fieldsToInclude: string[] = [];
				let tableFields: CaspioField[] = [];

				try {
					const fieldsResponse = (await caspioApiRequest.call(this, {
						method: 'GET',
						path: `/v3/tables/${tableName}/fields`,
					})) as { Result?: CaspioField[] };

					if (!fieldsResponse || !fieldsResponse.Result) {
						throw new NodeOperationError(
							this.getNode(),
							`Failed to fetch field information for table "${tableName}". Cannot create webhook without field data.`,
						);
					}

					tableFields = fieldsResponse.Result;
				} catch (error) {
					if (error instanceof NodeOperationError) {
						throw error;
					}
					throw new NodeOperationError(
						this.getNode(),
						`Unable to fetch table fields for "${tableName}": ${(error as Error).message}. Webhook creation requires field information.`,
					);
				}

				const allowedFields = filterOutPasswordFields(tableFields);

				if (!sendAllFields && selectedFields.length > 0) {
					fieldsToInclude = selectedFields;
				} else {
					fieldsToInclude = allowedFields.map((field: CaspioField) => field.Name);

					if (!fieldsToInclude.includes('PK_ID')) {
						fieldsToInclude.unshift('PK_ID');
					}
				}

				let customPayloadTemplate: string | undefined;
				if (fieldsToInclude.length > 0) {
					const attachmentFields: string[] = [];
					for (const field of allowedFields) {
						const fieldType = field.Type?.toLowerCase() || '';
						if (fieldType.includes('attachment')) {
							attachmentFields.push(field.Name);
						}
					}

					customPayloadTemplate = buildCustomPayloadTemplate(
						fieldsToInclude,
						attachmentFields,
						returnAttachmentUrls,
					);
				}

				const webhookBody: IDataObject = {
					Name: effectiveName,
					Description: desc,
					OutgoingUrls: [webhookUrl],
				};

				let wh: CaspioWebhook;
				try {
					wh = (await caspioApiRequest.call(this, {
						method: 'POST',
						path: '/v3/outgoingWebhooks',
						body: webhookBody,
					})) as CaspioWebhook;
				} catch (error) {
					const nodeError = error as NodeApiError;

					// If 400 error, likely duplicate webhook
					if (nodeError.httpCode === '400') {
						if (isTestWebhook) {
							throw new NodeOperationError(
								this.getNode(),
								'Test webhook already exists and could not be cleaned up. Please delete it manually in Caspio.',
							);
						} else {
							throw new NodeOperationError(
								this.getNode(),
								'Webhook with this URL already exists. <a href="https://howto.caspio.com/integrate-your-apps/integration-with-n8n/n8n-integration-triggers" target="_blank">See documentation</a>',
							);
						}
					}

					throw error;
				}

				if (!wh.Id) return false;
				webhookData.webhookId = wh.Id;
				storeHashedSecret(webhookData, wh.Secret as string);

				const eventType = 'table.record' + operation.charAt(0).toUpperCase() + operation.slice(1);
				const eventBody: IDataObject = {
					EventType: eventType,
					ObjectName: tableName,
					Enabled: true,
				};

				const defaultEventSources = [
					'DataPages',
					'DataParts',
					'Datasheet',
					'Extensions',
					'Tasks',
					'TriggeredActions',
				];
				if (
					advancedOptions.eventSources &&
					Array.isArray(advancedOptions.eventSources) &&
					advancedOptions.eventSources.length > 0
				) {
					eventBody.EventSources = advancedOptions.eventSources;
				} else {
					eventBody.EventSources = defaultEventSources;
				}

				if (operation === 'update' && !whenAnyFieldChanged && whenFieldsChanged.length > 0) {
					eventBody.ObjectFields = whenFieldsChanged;
				}

				if (customPayloadTemplate) {
					eventBody.CustomPayloadTemplate = customPayloadTemplate;
				}

				try {
					const ev = (await caspioApiRequest.call(this, {
						method: 'POST',
						path: `/v3/outgoingWebhooks/${wh.Id}/events`,
						body: eventBody,
					})) as IDataObject;
					if (!ev.Id) {
						await caspioApiRequest.call(this, {
							method: 'DELETE',
							path: `/v3/outgoingWebhooks/${wh.Id}`,
						});
						return false;
					}
					webhookData.eventId = ev.Id;
					return true;
				} catch (error) {
					await caspioApiRequest.call(this, {
						method: 'DELETE',
						path: `/v3/outgoingWebhooks/${wh.Id}`,
					});
					throw error;
				}
			},

			async delete(this: IHookFunctions): Promise<boolean> {
				const webhookData = this.getWorkflowStaticData('node');
				if (!webhookData.webhookId) return true;
				try {
					await caspioApiRequest.call(this, {
						method: 'DELETE',
						path: `/v3/outgoingWebhooks/${webhookData.webhookId}`,
					});
				} catch (error) {
					const apiError = error as Error & {
						httpCode?: number;
						cause?: {
							response?: { statusCode?: number };
							statusCode?: number;
						};
					};
					const status =
						apiError?.httpCode ??
						apiError?.cause?.response?.statusCode ??
						apiError?.cause?.statusCode;

					if (status === 404) {
						// 404 means webhook was already deleted, which is fine
					} else {
						const reason =
							(apiError as Error & { description?: string }).description ||
							apiError.message ||
							'Unknown error';

						throw new NodeOperationError(
							this.getNode(),
							`Failed to delete Caspio webhook (${webhookData.webhookId}). ${reason}. The webhook may remain active in Caspio and continue sending data.\n` +
								'Please restore permissions for the Web Services Profile used by these credentials to manage Outgoing Webhooks, or delete the webhook manually in Caspio.',
						);
					}
				}
				delete webhookData.webhookId;
				delete webhookData.salt;
				delete webhookData.secretHash;
				delete webhookData.eventId;
				return true;
			},
		},
	};

	async webhook(this: IWebhookFunctions): Promise<IWebhookResponseData> {
		const body = this.getBodyData() as IDataObject;
		const webhookData = this.getWorkflowStaticData('node');

		if (!body.secret) {
			throw new NodeOperationError(this.getNode(), 'Invalid webhook payload: Missing secret');
		}

		const incomingHash = hashSecret(body.secret as string, webhookData.salt as string);
		if (incomingHash !== webhookData.secretHash) {
			throw new NodeOperationError(this.getNode(), 'Webhook validation failed: Invalid secret');
		}

		if (body.webhookId && body.webhookId !== webhookData.webhookId) {
			throw new NodeOperationError(
				this.getNode(),
				'Webhook validation failed: Webhook ID mismatch',
			);
		}

		if (!body.messageId || !body.eventId) {
			throw new NodeOperationError(this.getNode(), 'Invalid Caspio webhook payload structure');
		}
		const sanitizedBody = { ...body };
		delete sanitizedBody.secret;

		return {
			workflowData: [this.helpers.returnJsonArray(sanitizedBody)],
		};
	}
}
